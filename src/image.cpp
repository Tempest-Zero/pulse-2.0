/**
 * @file image.cpp
 * @brief Image I/O implementation for PGM/PPM formats
 * @author Muhammad Bilal (2023394)
 * @course CS-361L - Computer Architecture Lab
 */

#include "image.hpp"
#include <fstream>
#include <sstream>
#include <cmath>
#include <algorithm>
#include <iostream>

namespace img {

namespace {

// Skip comments in PGM/PPM files
void skip_comments(std::istream& is) {
    char c;
    while (is.peek() == '#') {
        is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }
    // Skip whitespace
    while (is.peek() == ' ' || is.peek() == '\t' || is.peek() == '\n' || is.peek() == '\r') {
        is.get(c);
        if (is.peek() == '#') {
            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
    }
}

} // anonymous namespace

GrayscaleImage read_pgm(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + filename);
    }

    std::string magic;
    file >> magic;

    if (magic != "P5" && magic != "P2") {
        throw std::runtime_error("Invalid PGM format (expected P2 or P5): " + magic);
    }

    bool is_binary = (magic == "P5");

    skip_comments(file);

    int width, height, max_val;
    file >> width >> height;
    skip_comments(file);
    file >> max_val;

    if (width <= 0 || height <= 0 || max_val <= 0 || max_val > 65535) {
        throw std::runtime_error("Invalid PGM dimensions or max value");
    }

    // Skip single whitespace character after max_val
    file.get();

    GrayscaleImage img(width, height, max_val);

    if (is_binary) {
        // Binary format (P5)
        if (max_val <= 255) {
            file.read(reinterpret_cast<char*>(img.data.data()), width * height);
        } else {
            // 16-bit values
            for (int i = 0; i < width * height; ++i) {
                uint16_t val;
                file.read(reinterpret_cast<char*>(&val), 2);
                // Big-endian to native
                val = (val >> 8) | (val << 8);
                img.data[i] = static_cast<uint8_t>(val * 255 / max_val);
            }
        }
    } else {
        // ASCII format (P2)
        for (int i = 0; i < width * height; ++i) {
            int val;
            file >> val;
            img.data[i] = static_cast<uint8_t>(val * 255 / max_val);
        }
    }

    if (!file) {
        throw std::runtime_error("Error reading PGM file: " + filename);
    }

    return img;
}

void write_pgm(const std::string& filename, const GrayscaleImage& img) {
    std::ofstream file(filename, std::ios::binary);
    if (!file) {
        throw std::runtime_error("Cannot create file: " + filename);
    }

    // Write binary PGM (P5)
    file << "P5\n";
    file << "# Generated by OpenMP Image Filter\n";
    file << img.width << " " << img.height << "\n";
    file << "255\n";

    file.write(reinterpret_cast<const char*>(img.data.data()), img.data.size());

    if (!file) {
        throw std::runtime_error("Error writing PGM file: " + filename);
    }
}

RGBImage read_ppm(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + filename);
    }

    std::string magic;
    file >> magic;

    if (magic != "P6" && magic != "P3") {
        throw std::runtime_error("Invalid PPM format (expected P3 or P6): " + magic);
    }

    bool is_binary = (magic == "P6");

    skip_comments(file);

    int width, height, max_val;
    file >> width >> height;
    skip_comments(file);
    file >> max_val;

    if (width <= 0 || height <= 0 || max_val <= 0 || max_val > 65535) {
        throw std::runtime_error("Invalid PPM dimensions or max value");
    }

    file.get();  // Skip whitespace

    RGBImage img(width, height, max_val);

    if (is_binary) {
        if (max_val <= 255) {
            file.read(reinterpret_cast<char*>(img.data.data()), width * height * 3);
        } else {
            // 16-bit values
            for (size_t i = 0; i < img.data.size(); ++i) {
                uint16_t val;
                file.read(reinterpret_cast<char*>(&val), 2);
                val = (val >> 8) | (val << 8);
                img.data[i] = static_cast<uint8_t>(val * 255 / max_val);
            }
        }
    } else {
        // ASCII format (P3)
        for (size_t i = 0; i < img.data.size(); ++i) {
            int val;
            file >> val;
            img.data[i] = static_cast<uint8_t>(val * 255 / max_val);
        }
    }

    if (!file) {
        throw std::runtime_error("Error reading PPM file: " + filename);
    }

    return img;
}

void write_ppm(const std::string& filename, const RGBImage& img) {
    std::ofstream file(filename, std::ios::binary);
    if (!file) {
        throw std::runtime_error("Cannot create file: " + filename);
    }

    // Write binary PPM (P6)
    file << "P6\n";
    file << "# Generated by OpenMP Image Filter\n";
    file << img.width << " " << img.height << "\n";
    file << "255\n";

    file.write(reinterpret_cast<const char*>(img.data.data()), img.data.size());

    if (!file) {
        throw std::runtime_error("Error writing PPM file: " + filename);
    }
}

GrayscaleImage rgb_to_grayscale(const RGBImage& rgb) {
    GrayscaleImage gray(rgb.width, rgb.height);

    for (int y = 0; y < rgb.height; ++y) {
        for (int x = 0; x < rgb.width; ++x) {
            // Luminosity method: 0.299*R + 0.587*G + 0.114*B
            int idx = (y * rgb.width + x) * 3;
            float luminosity = 0.299f * rgb.data[idx] +
                             0.587f * rgb.data[idx + 1] +
                             0.114f * rgb.data[idx + 2];
            gray.pixel(x, y) = static_cast<uint8_t>(std::clamp(luminosity, 0.0f, 255.0f));
        }
    }

    return gray;
}

RGBImage grayscale_to_rgb(const GrayscaleImage& gray) {
    RGBImage rgb(gray.width, gray.height);

    for (int y = 0; y < gray.height; ++y) {
        for (int x = 0; x < gray.width; ++x) {
            uint8_t val = gray.pixel(x, y);
            rgb.r(x, y) = val;
            rgb.g(x, y) = val;
            rgb.b(x, y) = val;
        }
    }

    return rgb;
}

GrayscaleImage generate_test_image(int width, int height, int pattern) {
    GrayscaleImage img(width, height);

    switch (pattern) {
        case 0: // Gradient
            for (int y = 0; y < height; ++y) {
                for (int x = 0; x < width; ++x) {
                    // Diagonal gradient
                    float t = static_cast<float>(x + y) / (width + height - 2);
                    img.pixel(x, y) = static_cast<uint8_t>(t * 255);
                }
            }
            break;

        case 1: // Checkerboard
            {
                int check_size = std::max(1, std::min(width, height) / 16);
                for (int y = 0; y < height; ++y) {
                    for (int x = 0; x < width; ++x) {
                        bool white = ((x / check_size) + (y / check_size)) % 2 == 0;
                        img.pixel(x, y) = white ? 255 : 0;
                    }
                }
            }
            break;

        case 2: // Concentric circles
            {
                float cx = width / 2.0f;
                float cy = height / 2.0f;
                float max_dist = std::sqrt(cx * cx + cy * cy);
                for (int y = 0; y < height; ++y) {
                    for (int x = 0; x < width; ++x) {
                        float dx = x - cx;
                        float dy = y - cy;
                        float dist = std::sqrt(dx * dx + dy * dy);
                        float t = dist / max_dist;
                        // Create rings
                        float val = std::sin(t * 20 * M_PI) * 0.5f + 0.5f;
                        img.pixel(x, y) = static_cast<uint8_t>(val * 255);
                    }
                }
            }
            break;

        case 3: // Horizontal stripes with noise
            {
                int stripe_height = std::max(1, height / 20);
                for (int y = 0; y < height; ++y) {
                    for (int x = 0; x < width; ++x) {
                        bool white = (y / stripe_height) % 2 == 0;
                        // Add some variation
                        int noise = (x * 17 + y * 31) % 20 - 10;
                        int val = (white ? 200 : 55) + noise;
                        img.pixel(x, y) = static_cast<uint8_t>(std::clamp(val, 0, 255));
                    }
                }
            }
            break;

        case 4: // Edge test pattern (squares and lines)
            {
                // Fill with gray
                for (size_t i = 0; i < img.data.size(); ++i) {
                    img.data[i] = 128;
                }

                // Add white rectangles
                int rect_w = width / 4;
                int rect_h = height / 4;
                for (int y = rect_h; y < 2 * rect_h; ++y) {
                    for (int x = rect_w; x < 2 * rect_w; ++x) {
                        img.pixel(x, y) = 255;
                    }
                }
                for (int y = 2 * rect_h; y < 3 * rect_h; ++y) {
                    for (int x = 2 * rect_w; x < 3 * rect_w; ++x) {
                        img.pixel(x, y) = 0;
                    }
                }

                // Add diagonal line
                for (int i = 0; i < std::min(width, height); ++i) {
                    img.pixel(i, i) = 255;
                    if (i > 0) {
                        img.pixel(i - 1, i) = 200;
                        img.pixel(i, i - 1) = 200;
                    }
                }
            }
            break;

        default:
            // Default to gradient
            for (int y = 0; y < height; ++y) {
                for (int x = 0; x < width; ++x) {
                    float t = static_cast<float>(x) / (width - 1);
                    img.pixel(x, y) = static_cast<uint8_t>(t * 255);
                }
            }
            break;
    }

    return img;
}

} // namespace img
